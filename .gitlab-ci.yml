image: golang:1.24

stages:
  - prepare
  - quality
  - build

variables:
  # Cache et optimisations globales
  GOCACHE: "$CI_PROJECT_DIR/.cache/go-build"
  GOMODCACHE: "$CI_PROJECT_DIR/.cache/go-mod"
  GOPATH: "$CI_PROJECT_DIR/.cache/go-path"
  GOPROXY: "https://proxy.golang.org,direct"
  # CGO_ENABLED doit rester à 1 pour les tests avec -race

# Template de cache réutilisable
.go-cache:
  cache:
    key:
      files:
        - go.sum
    paths:
      - .cache/go-build
      - .cache/go-mod
      - .cache/go-path
    policy: pull

# Job de préparation des dépendances
📦 Prepare Dependencies:
  stage: prepare
  script:
    - go mod download
    - go mod verify
    # Pré-installer les outils pour les mettre en cache
    - go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.59.1
    - go install golang.org/x/vuln/cmd/govulncheck@latest
    # Vérifier que les outils sont installés
    - $GOPATH/bin/golangci-lint --version
    - $GOPATH/bin/govulncheck version
  cache:
    key:
      files:
        - go.sum
    paths:
      - .cache/go-build
      - .cache/go-mod
      - .cache/go-path
    policy: pull-push

# Jobs parallèles pour la qualité
💅 Lint:
  stage: quality
  extends: .go-cache
  needs: ["📦 Prepare Dependencies"]
  script:
    # Utiliser les binaires du cache
    - export PATH="$GOPATH/bin:$PATH"
    # Linter avec configuration optimisée
    - |
      $GOPATH/bin/golangci-lint run -v \
        --timeout 5m \
        --skip-files "tests/.*" \
        --disable typecheck \
        --concurrency 4 \
        --max-same-issues 0 \
        --max-issues-per-linter 0 || true
    # Vérification des vraies erreurs
    - |
      OUTPUT=$($GOPATH/bin/golangci-lint run --timeout 5m --disable typecheck 2>&1 || true)
      if echo "$OUTPUT" | grep -v "typecheck" | grep -E "\.go:[0-9]+:[0-9]+:"; then
        echo "Found real linting errors (not typecheck):"
        echo "$OUTPUT" | grep -v "typecheck"
        exit 1
      fi

🗄️ SQL Validation:
  stage: quality
  extends: .go-cache
  needs: ["📦 Prepare Dependencies"]
  before_script:
    # Installation rapide de postgresql-client
    - apt-get update -qq && apt-get install -y -qq postgresql-client > /dev/null
  script:
    - |
      echo "=== Analyzing SQL queries ==="
      
      # Recherche optimisée des fichiers SQL
      SQL_FILES=$(find . -name "*.go" -not -path "./vendor/*" -not -path "./tests/*" -type f -print0 | \
                  xargs -0 grep -l "SELECT\|INSERT\|UPDATE\|DELETE\|CREATE\|DROP\|ALTER" 2>/dev/null || true)
      
      if [ -z "$SQL_FILES" ]; then
        echo "No SQL queries found"
        exit 0
      fi
      
      # Analyse parallèle des fichiers
      echo "$SQL_FILES" | xargs -P 4 -I {} sh -c '
        echo "--- Analyzing {} ---"
        grep -n -E "(SELECT|INSERT|UPDATE|DELETE|CREATE|DROP|ALTER)" "{}" | head -20
      '
      
      # Vérifications de sécurité en une seule passe
      echo "=== Security checks ==="
      find . -name "*.go" -not -path "./vendor/*" -type f -print0 | \
        xargs -0 grep -n -E "(fmt\.Sprintf.*(SELECT|INSERT|UPDATE|DELETE)|\+ .*(SELECT|INSERT|UPDATE|DELETE))" || \
        echo "✓ No SQL injection vulnerabilities found"
      
      # Vérification des requêtes paramétrées
      find . -name "*.go" -not -path "./vendor/*" -type f -print0 | \
        xargs -0 grep -E "(db\.Exec|db\.Query)" | grep -v "\$" || \
        echo "✓ All queries appear to be parameterized"
  allow_failure: true

🧪 Tests:
  stage: quality
  extends: .go-cache
  needs: ["📦 Prepare Dependencies"]
  services:
    - name: docker:dind
      alias: docker
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  script:
    # Tests avec parallélisation (sans -race car CGO peut être désactivé en CI)
    - go test -p 4 -short -timeout 10m ./tests/...

📊 Coverage:
  stage: quality
  extends: .go-cache
  needs: ["📦 Prepare Dependencies"]
  services:
    - name: docker:dind
      alias: docker
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  script:
    # Coverage avec tests parallèles (sans -race pour éviter CGO)
    - go test -p 4 -coverprofile=coverage.out -covermode=atomic -coverpkg=./auth/...,./lib/...,./model/...,./validation/... ./tests/...
    # Utilisation d'awk pour éviter l'installation de bc
    - |
      COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
      echo "Total coverage: $COVERAGE%"
      awk -v cov="$COVERAGE" 'BEGIN { if (cov < 80.0) exit 1 }'
  coverage: '/^Total coverage: (\d+\.\d+)%$/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.out

🛡️ Security:
  stage: quality
  extends: .go-cache
  needs: ["📦 Prepare Dependencies"]
  script:
    - export PATH="$GOPATH/bin:$PATH"
    # Scan de vulnérabilités avec cache
    - $GOPATH/bin/govulncheck -scan package ./...

📦 Build:
  stage: build
  extends: .go-cache
  needs:
    - "💅 Lint"
    - "🧪 Tests"
    - "📊 Coverage"
    - "🛡️ Security"
  script:
    # Build optimisé avec parallélisation et CGO désactivé pour des binaires statiques
    - CGO_ENABLED=0 go build -p 4 -v -ldflags="-s -w" -o ./bin/ ./...
  artifacts:
    paths:
      - bin/
    expire_in: 1 week
