image: golang:1.24

stages:
  - prepare
  - quality
  - build

variables:
  # Cache et optimisations globales
  GOCACHE: "$CI_PROJECT_DIR/.cache/go-build"
  GOMODCACHE: "$CI_PROJECT_DIR/.cache/go-mod"
  GOPATH: "$CI_PROJECT_DIR/.cache/go-path"
  GOPROXY: "https://proxy.golang.org,direct"
  # CGO_ENABLED doit rester Ã  1 pour les tests avec -race

# Template de cache rÃ©utilisable
.go-cache:
  cache:
    key:
      files:
        - go.sum
    paths:
      - .cache/go-build
      - .cache/go-mod
      - .cache/go-path
    policy: pull

# Job de prÃ©paration des dÃ©pendances
ðŸ“¦ Prepare Dependencies:
  stage: prepare
  script:
    - go mod download
    - go mod verify
    # PrÃ©-installer les outils pour les mettre en cache
    - go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.59.1
    - go install golang.org/x/vuln/cmd/govulncheck@latest
    # VÃ©rifier que les outils sont installÃ©s
    - $GOPATH/bin/golangci-lint --version
    - $GOPATH/bin/govulncheck version
  cache:
    key:
      files:
        - go.sum
    paths:
      - .cache/go-build
      - .cache/go-mod
      - .cache/go-path
    policy: pull-push

# Jobs parallÃ¨les pour la qualitÃ©
ðŸ’… Lint:
  stage: quality
  extends: .go-cache
  needs: ["ðŸ“¦ Prepare Dependencies"]
  script:
    # Utiliser les binaires du cache
    - export PATH="$GOPATH/bin:$PATH"
    # Linter avec configuration optimisÃ©e
    - |
      $GOPATH/bin/golangci-lint run -v \
        --timeout 5m \
        --skip-files "tests/.*" \
        --disable typecheck \
        --concurrency 4 \
        --max-same-issues 0 \
        --max-issues-per-linter 0 || true
    # VÃ©rification des vraies erreurs
    - |
      OUTPUT=$($GOPATH/bin/golangci-lint run --timeout 5m --disable typecheck 2>&1 || true)
      if echo "$OUTPUT" | grep -v "typecheck" | grep -E "\.go:[0-9]+:[0-9]+:"; then
        echo "Found real linting errors (not typecheck):"
        echo "$OUTPUT" | grep -v "typecheck"
        exit 1
      fi

ðŸ—„ï¸ SQL Validation:
  stage: quality
  extends: .go-cache
  needs: ["ðŸ“¦ Prepare Dependencies"]
  before_script:
    # Installation rapide de postgresql-client
    - apt-get update -qq && apt-get install -y -qq postgresql-client > /dev/null
  script:
    - |
      echo "=== Analyzing SQL queries ==="
      
      # Recherche optimisÃ©e des fichiers SQL
      SQL_FILES=$(find . -name "*.go" -not -path "./vendor/*" -not -path "./tests/*" -type f -print0 | \
                  xargs -0 grep -l "SELECT\|INSERT\|UPDATE\|DELETE\|CREATE\|DROP\|ALTER" 2>/dev/null || true)
      
      if [ -z "$SQL_FILES" ]; then
        echo "No SQL queries found"
        exit 0
      fi
      
      # Analyse parallÃ¨le des fichiers
      echo "$SQL_FILES" | xargs -P 4 -I {} sh -c '
        echo "--- Analyzing {} ---"
        grep -n -E "(SELECT|INSERT|UPDATE|DELETE|CREATE|DROP|ALTER)" "{}" | head -20
      '
      
      # VÃ©rifications de sÃ©curitÃ© en une seule passe
      echo "=== Security checks ==="
      find . -name "*.go" -not -path "./vendor/*" -type f -print0 | \
        xargs -0 grep -n -E "(fmt\.Sprintf.*(SELECT|INSERT|UPDATE|DELETE)|\+ .*(SELECT|INSERT|UPDATE|DELETE))" || \
        echo "âœ“ No SQL injection vulnerabilities found"
      
      # VÃ©rification des requÃªtes paramÃ©trÃ©es
      find . -name "*.go" -not -path "./vendor/*" -type f -print0 | \
        xargs -0 grep -E "(db\.Exec|db\.Query)" | grep -v "\$" || \
        echo "âœ“ All queries appear to be parameterized"
  allow_failure: true

ðŸ§ª Tests:
  stage: quality
  extends: .go-cache
  needs: ["ðŸ“¦ Prepare Dependencies"]
  services:
    - name: docker:dind
      alias: docker
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  script:
    # Tests avec parallÃ©lisation (sans -race car CGO peut Ãªtre dÃ©sactivÃ© en CI)
    - go test -p 4 -short -timeout 10m ./tests/...

ðŸ“Š Coverage:
  stage: quality
  extends: .go-cache
  needs: ["ðŸ“¦ Prepare Dependencies"]
  services:
    - name: docker:dind
      alias: docker
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  script:
    # Coverage avec tests parallÃ¨les (sans -race pour Ã©viter CGO)
    - go test -p 4 -coverprofile=coverage.out -covermode=atomic -coverpkg=./auth/...,./lib/...,./model/...,./validation/... ./tests/...
    # Utilisation d'awk pour Ã©viter l'installation de bc
    - |
      COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
      echo "Total coverage: $COVERAGE%"
      awk -v cov="$COVERAGE" 'BEGIN { if (cov < 80.0) exit 1 }'
  coverage: '/^Total coverage: (\d+\.\d+)%$/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.out

ðŸ›¡ï¸ Security:
  stage: quality
  extends: .go-cache
  needs: ["ðŸ“¦ Prepare Dependencies"]
  script:
    - export PATH="$GOPATH/bin:$PATH"
    # Scan de vulnÃ©rabilitÃ©s avec cache
    - $GOPATH/bin/govulncheck -scan package ./...

ðŸ“¦ Build:
  stage: build
  extends: .go-cache
  needs:
    - "ðŸ’… Lint"
    - "ðŸ§ª Tests"
    - "ðŸ“Š Coverage"
    - "ðŸ›¡ï¸ Security"
  script:
    # Build optimisÃ© avec parallÃ©lisation et CGO dÃ©sactivÃ© pour des binaires statiques
    - CGO_ENABLED=0 go build -p 4 -v -ldflags="-s -w" -o ./bin/ ./...
  artifacts:
    paths:
      - bin/
    expire_in: 1 week
